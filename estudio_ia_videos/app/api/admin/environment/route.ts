import { NextRequest, NextResponse } from 'next/server';
import { cookies } from 'next/headers';
import crypto from 'crypto';
import fs from 'fs/promises';
import path from 'path';

const ENCRYPTION_KEY = process.env.CREDENTIALS_ENCRYPTION_KEY || 'mvp-encryption-key-2024-secure';
const ENV_FILE = '.env.production';

function encrypt(text: string): string {
  const algorithm = 'aes-256-cbc';
  const key = crypto.scryptSync(ENCRYPTION_KEY, 'salt', 32);
  const iv = crypto.randomBytes(16);
  const cipher = crypto.createCipheriv(algorithm, key, iv);
  let encrypted = cipher.update(text, 'utf8', 'hex');
  encrypted += cipher.final('hex');
  return iv.toString('hex') + ':' + encrypted;
}

async function verifyAdmin(): Promise<boolean> {
  const cookieStore = await cookies();
  const token = cookieStore.get('admin_token')?.value;
  return !!token;
}

interface EnvVariable {
  key: string;
  value: string;
  isSecret: boolean;
}

// GET - Obter variáveis de ambiente
export async function GET(request: NextRequest) {
  if (!await verifyAdmin()) {
    return NextResponse.json({ error: 'Não autorizado' }, { status: 401 });
  }

  try {
    const envPath = path.join(process.cwd(), ENV_FILE);
    const variables: EnvVariable[] = [];

    try {
      const content = await fs.readFile(envPath, 'utf8');
      const lines = content.split('\n');

      lines.forEach(line => {
        const trimmed = line.trim();
        if (trimmed && !trimmed.startsWith('#')) {
          const [key, ...valueParts] = trimmed.split('=');
          const value = valueParts.join('=');
          if (key) {
            variables.push({
              key: key.trim(),
              value: value.trim(),
              isSecret: key.includes('KEY') || key.includes('SECRET') || key.includes('PASSWORD') || key.includes('TOKEN')
            });
          }
        }
      });
    } catch {
      // Arquivo não existe, retornar variáveis de ambiente atuais
      const defaultVars = [
        'NODE_ENV',
        'NEXT_PUBLIC_SUPABASE_URL',
        'NEXT_PUBLIC_SUPABASE_ANON_KEY',
        'SUPABASE_SERVICE_ROLE_KEY',
        'DIRECT_DATABASE_URL',
        'REDIS_URL',
        'ELEVENLABS_API_KEY',
        'HEYGEN_API_KEY',
        'OPENAI_API_KEY',
        'AZURE_SPEECH_KEY',
        'AZURE_SPEECH_REGION',
        'AWS_ACCESS_KEY_ID',
        'AWS_SECRET_ACCESS_KEY',
        'AWS_REGION',
        'AWS_S3_BUCKET',
        'NEXTAUTH_SECRET',
        'NEXTAUTH_URL',
        'SENTRY_DSN',
        'LOG_LEVEL',
        'ADMIN_EMAIL'
      ];

      defaultVars.forEach(key => {
        const value = process.env[key];
        if (value) {
          variables.push({
            key,
            value,
            isSecret: key.includes('KEY') || key.includes('SECRET') || key.includes('PASSWORD') || key.includes('TOKEN')
          });
        }
      });
    }

    return NextResponse.json({ variables });

  } catch (error) {
    console.error('[ADMIN ENV] Erro ao obter variáveis:', error);
    return NextResponse.json(
      { error: 'Erro ao obter variáveis de ambiente' },
      { status: 500 }
    );
  }
}

// POST - Salvar variáveis de ambiente
export async function POST(request: NextRequest) {
  if (!await verifyAdmin()) {
    return NextResponse.json({ error: 'Não autorizado' }, { status: 401 });
  }

  try {
    const { variables } = await request.json() as { variables: EnvVariable[] };

    if (!variables || !Array.isArray(variables)) {
      return NextResponse.json(
        { error: 'Variáveis inválidas' },
        { status: 400 }
      );
    }

    // Gerar conteúdo do arquivo .env
    const header = `# ============================================
# Production Environment Variables
# Generated by Admin Panel
# ${new Date().toISOString()}
# ============================================

`;

    const content = variables
      .filter(v => v.key && v.value)
      .map(v => `${v.key}=${v.value}`)
      .join('\n');

    const envPath = path.join(process.cwd(), ENV_FILE);
    await fs.writeFile(envPath, header + content + '\n', 'utf8');

    console.log(`[ADMIN ENV] Variáveis de ambiente salvas em ${new Date().toISOString()}`);

    return NextResponse.json({
      success: true,
      message: 'Variáveis de ambiente salvas com sucesso',
      count: variables.length
    });

  } catch (error) {
    console.error('[ADMIN ENV] Erro ao salvar variáveis:', error);
    return NextResponse.json(
      { error: 'Erro ao salvar variáveis de ambiente' },
      { status: 500 }
    );
  }
}
